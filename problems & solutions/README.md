## A. Размещение данных

Ограничения
1 сек.
256 MiB

Телекоммуникационная сеть крупной IT-компании содержит n серверов, пронумерованных от 1 до n
. Некоторые пары серверов соединены двусторонними каналами связи, всего в сети m каналов. Гарантируется, что сеть серверов устроена таким образом, что по каналам связи можно передавать данные с любого сервера на любой другой сервер, возможно с использованием одного или нескольких промежуточных серверов.

Множество серверов A
 называется отказоустойчивым, если при недоступности любого канала связи выполнено следующее условие. Для любого не входящего в это множество сервера X
 существует способ передать данные по остальным каналам на сервер X
 хотя бы от одного сервера из множества A
.

На рис. 1 показан пример сети и отказоустойчивого множества из серверов с номерами 1 и 4. Данные на сервер 2 можно передать следующим образом. При недоступности канала между серверами 1 и 2 — с сервера 4, при недоступности канала между серверами 2 и 3 — с сервера 1. На серверы 3 и 5 при недоступности любого канала связи можно по другим каналам передать данные с сервера 4.

В рамках проекта группе разработчиков компании необходимо разместить свои данные в сети. Для повышения доступности данных и устойчивости к авариям разработчики хотят продублировать свои данные, разместив их одновременно на нескольких серверах, образующих отказоустойчивое множество. Чтобы минимизировать издержки, необходимо выбрать минимальное по количеству серверов отказоустойчивое множество. Кроме того, чтобы узнать, насколько гибко устроена сеть, необходимо подсчитать количество способов выбора такого множества, и поскольку это количество способов может быть большим, необходимо найти остаток от деления этого количества способов на число 109+7
.

Требуется написать программу, которая по заданному описанию сети определяет следующие числа: k
 — минимальное количество серверов в отказоустойчивом множестве серверов, c
 — остаток от деления количества способов выбора отказоустойчивого множества из k
 серверов на число 10^9+7

### Входные данные

Первая строка входного файла содержит целые числа n
 и m
 — количество серверов и количество каналов связи соответственно (2≤n≤200000
, 1≤m≤200000
). Следующие m
 строк содержат по два целых числа и описывают каналы связи между серверами. Каждый канал связи задается двумя целыми числами: номерами серверов, которые он соединяет.

Гарантируется, что любые два сервера соединены напрямую не более чем одним каналом связи, никакой канал не соединяет сервер сам с собой, и для любой пары серверов существует способ передачи данных с одного из них на другой, возможно с использованием одного или нескольких промежуточных серверов.

### Выходные данные

Выведите два целых числа, разделенных пробелом: k
 — минимальное число серверов в отказоустойчивом множестве серверов, c
 — количество способов выбора отказоустойчивого множества из k
 серверов, взятое по модулю 10^9+7

### Примеры

#### входные данные

```
5 5
1 2
2 3
3 4
3 5
4 5
```

#### выходные данные

```
2 3
```

## [Решение](https://github.com/as4del/algorithms-and-data-structures/blob/main/problems%20%26%20solutions/A.cpp)

____

## B. Минимизация мостов

Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт

Добавить в граф G = (V, E) (возможно несвязный, с петлями и кратными рёбрами) ровно одно
ребро, так чтобы количество мостов в данном графе стало минимально возможным.
Напомним, что мостом в графе называется такое ребро, удаление которого увеличивает число
компонент связности графа.

### Входные данные

Первая строка входного файла содержит два натуральных числа n и m – количества вершин и
рёбер графа соответственно (1 6 n 6 200 000, 1 6 m 6 200 000).
Следующие m строк содержат описание рёбер по одному на строке. Ребро номер i описывается
двумя натуральными числами vi, ui – номерами концов ребра (1 6 vi, ui 6 n).

### Выходные данные

Выведите наименьшее число мостов, которое можно получить добавлением ровно одного ребра.

### Примеры

#### входные данные
```
6 7
1 2
2 3
3 4
1 3
4 5
4 6
5 6
```

#### выходные данные

```
0
```

## [Решение](https://github.com/as4del/algorithms-and-data-structures/blob/main/problems%20%26%20solutions/B.cpp)
