## A. Размещение данных

Ограничения
1 сек.
256 MiB

Телекоммуникационная сеть крупной IT-компании содержит n серверов, пронумерованных от 1 до n
. Некоторые пары серверов соединены двусторонними каналами связи, всего в сети m каналов. Гарантируется, что сеть серверов устроена таким образом, что по каналам связи можно передавать данные с любого сервера на любой другой сервер, возможно с использованием одного или нескольких промежуточных серверов.

Множество серверов A
 называется отказоустойчивым, если при недоступности любого канала связи выполнено следующее условие. Для любого не входящего в это множество сервера X
 существует способ передать данные по остальным каналам на сервер X
 хотя бы от одного сервера из множества A
.

На рис. 1 показан пример сети и отказоустойчивого множества из серверов с номерами 1 и 4. Данные на сервер 2 можно передать следующим образом. При недоступности канала между серверами 1 и 2 — с сервера 4, при недоступности канала между серверами 2 и 3 — с сервера 1. На серверы 3 и 5 при недоступности любого канала связи можно по другим каналам передать данные с сервера 4.

В рамках проекта группе разработчиков компании необходимо разместить свои данные в сети. Для повышения доступности данных и устойчивости к авариям разработчики хотят продублировать свои данные, разместив их одновременно на нескольких серверах, образующих отказоустойчивое множество. Чтобы минимизировать издержки, необходимо выбрать минимальное по количеству серверов отказоустойчивое множество. Кроме того, чтобы узнать, насколько гибко устроена сеть, необходимо подсчитать количество способов выбора такого множества, и поскольку это количество способов может быть большим, необходимо найти остаток от деления этого количества способов на число 109+7
.

Требуется написать программу, которая по заданному описанию сети определяет следующие числа: k
 — минимальное количество серверов в отказоустойчивом множестве серверов, c
 — остаток от деления количества способов выбора отказоустойчивого множества из k
 серверов на число 10^9+7

### Входные данные

Первая строка входного файла содержит целые числа n
 и m
 — количество серверов и количество каналов связи соответственно (2≤n≤200000
, 1≤m≤200000
). Следующие m
 строк содержат по два целых числа и описывают каналы связи между серверами. Каждый канал связи задается двумя целыми числами: номерами серверов, которые он соединяет.

Гарантируется, что любые два сервера соединены напрямую не более чем одним каналом связи, никакой канал не соединяет сервер сам с собой, и для любой пары серверов существует способ передачи данных с одного из них на другой, возможно с использованием одного или нескольких промежуточных серверов.

### Выходные данные

Выведите два целых числа, разделенных пробелом: k
 — минимальное число серверов в отказоустойчивом множестве серверов, c
 — количество способов выбора отказоустойчивого множества из k
 серверов, взятое по модулю 10^9+7

### Примеры

#### входные данные

```
5 5
1 2
2 3
3 4
3 5
4 5
```

#### выходные данные

```
2 3
```

## [Решение](https://github.com/as4del/algorithms-and-data-structures/blob/main/problems%20%26%20solutions/A.cpp)

____

## B. Минимизация мостов

Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт

Добавить в граф G = (V, E) (возможно несвязный, с петлями и кратными рёбрами) ровно одно
ребро, так чтобы количество мостов в данном графе стало минимально возможным.
Напомним, что мостом в графе называется такое ребро, удаление которого увеличивает число
компонент связности графа.

### Входные данные

Первая строка входного файла содержит два натуральных числа n и m – количества вершин и
рёбер графа соответственно (1 6 n 6 200 000, 1 6 m 6 200 000).
Следующие m строк содержат описание рёбер по одному на строке. Ребро номер i описывается
двумя натуральными числами vi, ui – номерами концов ребра (1 6 vi, ui 6 n).

### Выходные данные

Выведите наименьшее число мостов, которое можно получить добавлением ровно одного ребра.

### Примеры

#### входные данные
```
6 7
1 2
2 3
3 4
1 3
4 5
4 6
5 6
```

#### выходные данные

```
0
```

## [Решение](https://github.com/as4del/algorithms-and-data-structures/blob/main/problems%20%26%20solutions/B.cpp)

____

## C. A и B и аудитории

ограничение по времени на тест 2 секунды
ограничение по памяти на тест 256 мегабайт

A и B готовятся к олимпиадам про программированию.

Университет, в котором учатся A и B, представляет собой множество аудиторий, соединенных между собой переходами. Всего в университете n аудиторий, соединённых n - 1 переходом таким образом, что из любой аудитории можно дойти до любой по переходам. Аудитории пронумерованы от 1 до n.

Каждый день А и B пишут контесты в некоторых аудиториях своего университета, и после каждого контеста они собираются вместе в одной аудитории и обсуждают задачи. A и B хотят, чтобы расстояния от аудитории, где они будут обсуждать задачи, до аудиторий, где они пишут контесты, были равны. Расстоянием между двумя аудиториями является количество ребер на кратчайшем пути между ними.

Так как каждый день они пишут контесты в новых аудиториях, то они попросили вас помочь им найти количество возможных аудиторий для обсуждения задач на каждый из ближайших m дней.


### Входыне данные

В первой строке задано целое число n (1 ≤ n ≤ 10^5) — количество аудиторий в университете.

В следующих n - 1 строках описаны переходы. В i-й из этих строк (1 ≤ i ≤ n - 1) записаны два целых числа ai и bi (1 ≤ ai, bi ≤ n), обозначающих, что i-й переход соединяет аудитории с номерами ai и bi.

В следующей строке записано целое число m (1 ≤ m ≤ 10^5) — количество запросов.

Следующие m строк описывают сами запросы. В j-й из этих строк (1 ≤ j ≤ m) записаны два целых числа xj и yj (1 ≤ xj, yj ≤ n), обозначающих, что в j-й день A будет писать контест в аудитории с номером xj, B — в аудитории с номером yj.

### Выходные данные

В i-й (1 ≤ i ≤ m) строке выведите количество аудиторий, равноудаленных от аудиторий, в которых A и B пишут контест в i-й день.

### Примеры

#### входыне данные

```
4
1 2
1 3
2 4
1
2 3
```

#### выходыне данные

```
1
```

#### входные данные

```
4
1 2
2 3
2 4
2
1 2
1 3
```

#### выходные данные

```
0
2
```

## [Решение](https://github.com/as4del/algorithms-and-data-structures/blob/main/problems%20%26%20solutions/%D0%A1.cpp)

____

## D. Дайте поспать

ограничение по времени на тест 5 s.
ограничение по памяти на тест 256 MB

Как всем известно, ленивцы живут на деревьях. У Саши есть домашний ленивец, которому он позволяет играть на своих невзвешенных деревьях, когда решает задачи. Иногда Саша замечает, что его ленивец находится на определенной вершине a
 в дереве, и просит его переместиться на какую-нибудь другую вершину b
.

Конечно, у ленивца настолько благие намерения, насколько это возможно, но, увы, у него достаточно энергии, чтобы перемещаться не более чем по c
ребрам. Если ленивцу нужно пересечь меньше c ребер, чтобы добраться до вершины b, он доберется туда, а затем вздремнет. В противном случае он подойдет как можно ближе, прежде чем повиснет в ожидании дальнейшего переваривания.
Где окажется ленивец в конце концов? Кроме того, поскольку это случается довольно часто, Саша хотел бы, чтобы вы ответили на q независимых запросов.

### Входные данные 

Первая строка будет содержать одно целое число n
, количество вершин в дереве. Следующие n−1
 строк будут содержать два целых числа u
 и v
, описывающие ребра в дереве.

После этого появится строка, содержащая целое число q
, количество раз, когда Саша будет мотивировать своего ленивца двигаться. Далее следуют q строк, каждая из которых содержит три целых числа a, b и c: вершина, с которой ленивец начинает, вершина, к которой Саша просит ленивца перейти, и энергия, которую ленивец имеет изначально.

1≤n,q≤3∗10 ^ 5

1≤a,b,c,u,v≤n

### Выходные данные

Найдите номер вершины, где ленивец должен будет остановиться

### Примеры

#### входные данные

```
1
1
1 1 1
```

#### выходыне данные

```
1
```

#### входные данные

```
5
4 2
1 4
5 4
3 4
5
3 5 2
3 5 4
1 5 5
4 5 4
1 5 4
```

#### выходные данные

```
5
5
5
5
5
```

## [Решение](https://github.com/as4del/algorithms-and-data-structures/blob/main/problems%20%26%20solutions/D.cpp)

____

## E. Миссия выполнима!

Ограничение по времени: 1 секунда
Ограничение по памяти: 1024 мегабайта

Агент Итан получил задания по сбору секретных документах в лаборатории. Лаборатория состоит из n комнат, соединенных n−1 коридорами. Каждый коридор соединяет две различные комнаты,
из любой комнаты есть путь до любой другой, переход по коридору i, соединяющему комнаты ai, bi занимает ci > 0 времени.
Когда Итан проник в комнату с номером x, сработала сигнализация. По заданию ему нужно посетить еще k любых различных комнат в лаборатории (включая x, она уже считается посещенной).
Для оценки возможности завершения миссии, необходимо вычислить минимальное время, необходимое для посещения k любых различных комнат в лаборатории (включая x, она уже считается
посещенной). Порядок посещения комнат и комната, в которой посещение закончится не имеют
значения. Возвращаться в комнату x не обязательно.
Ваша миссия, если Вы возьметесь за ее выполнение, – вычислить искомое минимальное время.

### Входные данные

Первая строка содержит целые числа n, k и x (1 6 k, x 6 n 6 10^4).
Следующие n−1 строк описывают коридоры тремя числами ai, bi, ci (1 6 ai, bi 6 n; 0 6 ci 6 10^4).
Это означает, что переход между комнатами ai, bi занимает ci времени.
Дополнительные ограничения: k 6 min(n, 100), каждая комната соединена коридором напрямую
не более чем с 3 комнатами

### Выходные данные

Выведите единственное целое число – минимальное время, необходимое для посещения k различных комнат.

### Примеры

#### входные данные

```
0 8 3
1 3 3
3 2 5
6 4 5
1 8 3
9 1 2
9 10 2
3 7 10
6 7 1
7 5 1
```

####  выходные данные

```
32
```

#### входные данные

```
3 1 1
1 2 4
2 3 0
```

#### выходные данные

```
0
```

## [Решение](https://github.com/as4del/algorithms-and-data-structures/blob/main/problems%20%26%20solutions/E.cpp)
В этой задаче мой код далек от идеала
